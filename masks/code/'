#!/usr/bin/env python3

import numpy as np
import gdspy
import matplotlib.pyplot as plt
from scipy import constants,special
import astropy.units as u
number_of_points = 32

mUnits = 1e-6
wafer_width = 101e3
wafer_len = 101e3
inv_margin = 200
edge_margin = 500
finger_length = 900
indboxwidth = 325.
indboxheight = 127.
coup_cap_finger_length = 100
bondpad_size = 140
island_halfwidth = 400
Qi = 40000
Z0 = 50 * u.Ohm
gnd_box_margin = 200




def moveabove_get_shift(box_fixed,box_free):
  (fixed_llx,fixed_lly),(fixed_urx,fixed_ury) = box_fixed
  (free_llx,free_lly),(free_urx,free_ury) = box_free

  fixed_top = fixed_ury
  free_bottom = free_lly

  yshift = (fixed_top - free_bottom)
  return yshift

def moveabove(object_fixed,object_free,spacing=0):
  box_fixed = object_fixed.get_bounding_box()
  box_free = object_free.get_bounding_box()
  yshift = moveabove_get_shift(box_fixed,box_free)
  object_free.translate(0,yshift-spacing)

def movebelow_get_shift(box_fixed,box_free):
  (fixed_llx,fixed_lly),(fixed_urx,fixed_ury) = box_fixed
  (free_llx,free_lly),(free_urx,free_ury) = box_free

  fixed_bottom = fixed_lly
  free_top = free_ury

  yshift = (fixed_bottom - free_top)
  return yshift

def movebelow(object_fixed,object_free,spacing=0):
  box_fixed = object_fixed.get_bounding_box()
  box_free = object_free.get_bounding_box()
  yshift = movebelow_get_shift(box_fixed,box_free)
  object_free.translate(0,yshift-spacing)

def moveleft_get_shift(box_fixed,box_free):
  (fixed_llx,fixed_lly),(fixed_urx,fixed_ury) = box_fixed
  (free_llx,free_lly),(free_urx,free_ury) = box_free

  fixed_left = fixed_llx
  free_right = free_urx

  xshift = (fixed_left - free_right)
  return xshift

def moveleft(object_fixed,object_free,spacing=0):
  box_fixed = object_fixed.get_bounding_box()
  box_free = object_free.get_bounding_box()
  xshift = moveleft_get_shift(box_fixed,box_free)
  object_free.translate(xshift-spacing,0)

def moveright_get_shift(box_fixed,box_free):
  (fixed_llx,fixed_lly),(fixed_urx,fixed_ury) = box_fixed
  (free_llx,free_lly),(free_urx,free_ury) = box_free

  fixed_right = fixed_urx
  free_right = free_llx

  xshift = (fixed_right - free_right)
  return xshift

def moveright(object_fixed,object_free,spacing=0):
  box_fixed = object_fixed.get_bounding_box()
  box_free = object_free.get_bounding_box()
  xshift = moveright_get_shift(box_fixed,box_free)
  object_free.translate(xshift-spacing,0)

def centerx_get_shift(box_fixed,box_free):
  (fixed_llx,fixed_lly),(fixed_urx,fixed_ury) = box_fixed
  (free_llx,free_lly),(free_urx,free_ury) = box_free

  fixed_mid = 0.5*(fixed_llx + fixed_urx)
  free_mid = 0.5*(free_llx + free_urx)

  xshift = (fixed_mid - free_mid)
  return xshift

def centerx(object_fixed,object_free):
  box_fixed = object_fixed.get_bounding_box()
  box_free = object_free.get_bounding_box()
  xshift = centerx_get_shift(box_fixed,box_free)
  object_free.translate(xshift,0)

def centery_get_shift(box_fixed,box_free):
  (fixed_llx,fixed_lly),(fixed_urx,fixed_ury) = box_fixed
  (free_llx,free_lly),(free_urx,free_ury) = box_free

  fixed_mid = 0.5*(fixed_lly + fixed_ury)
  free_mid = 0.5*(free_lly + free_ury)

  yshift = (fixed_mid - free_mid)
  return yshift

def centery(object_fixed,object_free):
  box_fixed = object_fixed.get_bounding_box()
  box_free = object_free.get_bounding_box()
  yshift = centery_get_shift(box_fixed,box_free)
  object_free.translate(0,yshift)

class InductorMeander():
  def __init__(self):
    self.tracewidth = 1.0
    self.gap = 1.0
    self.boxwidth = indboxwidth
    self.boxheight = indboxheight
    self.x0 = 0
    self.y0 = 0
    self.layer = 0
    self.cellname = 'Inductor'
  def draw(self):
    path = gdspy.Path(self.tracewidth,(self.x0,self.y0))
    specseg = {'layer':self.layer}
    specturn = {'layer':self.layer,'number_of_points':number_of_points}
    radius = 0.5*(self.gap + self.tracewidth)
    turnwidth = 0.5*self.gap + self.tracewidth
    path.segment(turnwidth,**specseg)
    seglen = self.boxwidth - 2*turnwidth
    while path.y - self.y0 + 4*(self.gap + self.tracewidth) < self.boxheight:
      path.segment(seglen,**specseg)
      path.turn(radius,'ll',**specturn)
      path.segment(seglen,**specseg)
      path.turn(radius,'rr',**specturn)
    path.segment(seglen,**specseg)
    path.turn(radius,'ll',**specturn)
    path.segment(seglen,**specseg)
    path.segment(turnwidth,**specseg)
    self.x1,self.y1 = path.x,path.y

    self.cell = gdspy.Cell(self.cellname)
    self.cell.add(path)
    return self.cell

class IDC():
  def __init__(self,capfrac):
    self.trace_width = 2.
    self.gap_width = 2.
    self.finger_length = 900.
    self.finger_gap = 2.
    self.nfinger = 64
    self.contact_width = self.trace_width
    self.width = self.contact_width + self.finger_gap + self.finger_length + self.contact_width
    self.height = self.nfinger*(self.gap_width+self.trace_width) + self.trace_width
    self.capfrac = capfrac
    self.cellname = 'Capacitor'
    self.layer= 6 
    self.C = self.capacitance()

  def draw(self, less_one=False):
    dx = self.finger_length + self.gap_width + self.contact_width
    dy = self.nfinger*(self.gap_width + self.trace_width) + self.trace_width
    self.make_fingers(less_one)
    self.make_contacts()
    self.C = self.capacitance()

    self.left_contact.layer = self.layer
    self.left_contact.translate(-dx/2, -dy/2)
    self.right_contact.translate(-dx/2, -dy/2)
    self.right_contact.layer = self.layer
    self.cell = gdspy.Cell(self.cellname)
    for f in self.fingers:
      f.layer = self.layer
      f.translate(-dx/2, -dy/2)
      self.cell.add(f)
    self.cell.add(self.left_contact)
    self.cell.add(self.right_contact)

    return self.cell

  def capacitance2(self):
    p = mUnits*(self.finger_length - self.finger_gap)
    q = mUnits*self.height
    s = mUnits*self.gap_width
    w = mUnits*self.trace_width
    a = s + w
    e = constants.epsilon_0 * 11.7

    c = 0.0
    for n in range(1,100):
      j = special.j0((2*n-1)*pi*s/(2*a))
      c += (1.0/(2*n-1)) * j*j

    c *= p*q*(4.*e/(pi*a))
    return c

  def capacitance(self):
    e0 = constants.epsilon_0
    e1 = 1.0
    es = 11.7

    w = mUnits*self.trace_width
    g = mUnits*self.gap_width
    h = mUnits*self.finger_length
    N = int(self.nfinger*self.capfrac) - 1
    l = 2. * (w + g)
    eta = 2.*w/l
    kiinf = np.sin(np.pi*eta / 2.)
    kiinfp = np.sqrt(1 - kiinf**2)
    keinf = 2.*np.sqrt(eta) / (1 + eta)
    keinfp = np.sqrt(1 - keinf**2)

    Kkiinf = special.ellipk(kiinf)
    Kkiinfp = special.ellipk(kiinfp)
    Kkeinf = special.ellipk(keinf)
    Kkeinfp = special.ellipk(keinfp)

    Ci = e0 * (1+es) * h * Kkiinf/Kkiinfp
    Ce = e0 * (1+es) * h * Kkeinf/Kkeinfp
    Ct = (N-3) * Ci/2 + 2*(Ci*Ce)/(Ci+Ce)
    return Ct

  def make_fingers(self, less_one):
    self.fingers = []
    xcur = 0.
    ycur = 0.

    left_fingers = []
    right_fingers = []

    nrf = (self.nfinger + 1) / 2
    nrfx = nrf * self.capfrac
    #print "nrfx: ",nrfx
    nrff = int(nrfx)    # Number of right fingers to leave fully intact
    nrfr = nrfx - nrff    # How much to truncate the last right finger

    minx = xcur + self.finger_gap
    maxx = xcur + self.finger_length
    partialx = nrfr * minx + (1-nrfr) * maxx

    range_val = self.nfinger + 1
    if less_one:
      range_val = self.nfinger

    for i in range(range_val):
      if i % 2 == 0:
        lower_leftx = xcur
        upper_rightx = xcur + self.finger_length
      else:
        if i/2 == nrff:
          lower_leftx = partialx
          upper_rightx = xcur + self.finger_length + self.finger_gap
        else:
          lower_leftx = xcur+self.finger_gap
          upper_rightx = lower_leftx + self.finger_length

      assert lower_leftx >= 0.
      assert upper_rightx <= self.finger_length + self.finger_gap

      lower_lefty = ycur
      upper_righty = lower_lefty + self.trace_width

      ycur += self.trace_width + self.gap_width
      box = gdspy.Rectangle([lower_leftx,lower_lefty],[upper_rightx,upper_righty])
      if i % 2 == 0:
        self.fingers.append(box)
      elif (i/2) <= nrff:
        self.fingers.append(box)

  def make_contacts(self):
    lower_leftx = -self.contact_width
    lower_lefty = 0.
    upper_rightx = lower_leftx + self.contact_width
    upper_righty = lower_lefty + self.nfinger*(self.gap_width + self.trace_width) + self.trace_width
    self.left_contact = gdspy.Rectangle([lower_leftx,lower_lefty],[upper_rightx,upper_righty])
    lower_leftx = self.finger_gap + self.finger_length
    upper_rightx = lower_leftx + self.contact_width
    self.right_contact = gdspy.Rectangle([lower_leftx,lower_lefty],[upper_rightx,upper_righty])

def Rectangle(x0,y0,x1,y1):
  r = gdspy.Rectangle((x0,y0),(x1,y1))
  def get_bounding_box():
    pt0,pt1,pt2,pt3 = r.points
    return pt0,pt2
  r.get_bounding_box = get_bounding_box
  return r

def makechipoutline(wafer_w, wafer_l):
  specs = {'layer':10}
  outline = gdspy.Path(1, (0,0))
  #outline.layers = [0]
  outline.segment(wafer_w, '+x', **specs)
  outline.segment(wafer_l, '+y', **specs)
  outline.segment(wafer_w, '-x', **specs)
  outline.segment(wafer_l, '-y', **specs)
  outlinecell = gdspy.Cell('WaferOutline')
  outlinecell.add(outline)
  return outlinecell

def getnumfingers(cap, target_C):
  e0 = constants.epsilon_0
  e1 = 1.0
  es = 11.7

  w = mUnits*cap.trace_width
  g = mUnits*cap.gap_width
  h = mUnits*cap.finger_length
  l = 2. * (w + g)
  eta = 2.*w/l
  kiinf = np.sin(np.pi*eta / 2.)
  kiinfp = np.sqrt(1 - kiinf**2)
  keinf = 2.*np.sqrt(eta) / (1 + eta)
  keinfp = np.sqrt(1 - keinf**2)

  Kkiinf = special.ellipk(kiinf)
  Kkiinfp = special.ellipk(kiinfp)
  Kkeinf = special.ellipk(keinf)
  Kkeinfp = special.ellipk(keinfp)

  Ci = e0 * (1+es) * h * Kkiinf/Kkiinfp
  Ce = e0 * (1+es) * h * Kkeinf/Kkeinfp
  n = (target_C -  2*(Ci*Ce)/(Ci+Ce)) * 2/Ci + 4
  nfingers = int(n)
  capfrac = n - nfingers

  return nfingers, capfrac


def invert_cell(cell):
  cell_name = cell.name + '_r'
  inv_cell = gdspy.Cell(cell_name)
  (xmin, ymin), (xmax, ymax) = cell.get_bounding_box()
  dx = (xmax - xmin) + 2*inv_margin
  dy = (ymax - ymin) + 2*inv_margin
  layer = cell.get_layers().pop()
  polys = cell.get_polygons(depth=1)
  polyset = gdspy.PolygonSet(polys, layer=layer)
  bbox = gdspy.Rectangle([-dx/2, dy/2], [dx/2, -dy/2], layer=layer)

  new_polyset = gdspy.fast_boolean(polyset, bbox, 'xor', layer=layer)
  inv_cell.add(new_polyset)
  return inv_cell

def make_cap_to_ind_lines():
  layer = 8
  cell_name = 'connector'
  ms_width = 2
  len_conn = (finger_length + 3 * ms_width -ms_width)/2
  cap2ind_conn = gdspy.Cell(cell_name)
  #box = gdspy.Rectangle(layer=layer)
  conn1 = gdspy.Path(ms_width, (0,0))
  conn1.segment(5*ms_width, '+x', layer=layer)
  conn2 = gdspy.Path(ms_width, (conn1.x - ms_width/2, conn1.y + ms_width/2))
  conn2.segment(len_conn , '-y', layer=layer)
  conn3 = gdspy.Path(ms_width, (conn2.x - ms_width/2, conn2.y + ms_width/2))
  conn3.segment(island_halfwidth - 5*ms_width + ms_width + 1.25*ms_width, '+x', layer=layer)
  conn4 = gdspy.Path(ms_width, (conn3.x - ms_width/2, conn3.y - ms_width/2))
  conn4.segment(12.5, '+y', layer=layer)
  conn5 = gdspy.Path(2.5*ms_width, (conn4.x, conn4.y - ms_width/2))
  conn5.segment(51, '+y', layer=layer)

  dx = island_halfwidth/2
  dy = len_conn/2 - ms_width/2
  conn1.translate(-dx, dy)
  conn2.translate(-dx, dy)
  conn3.translate(-dx, dy)
  conn4.translate(-dx, dy)
  conn5.translate(-dx, dy)

  cap2ind_conn.add(conn1)
  cap2ind_conn.add(conn2)
  cap2ind_conn.add(conn3)
  cap2ind_conn.add(conn4)
  cap2ind_conn.add(conn5)


  return cap2ind_conn

def get_inductor():
  fn = '../resobolo_files/new_inductor.gds'
  gdsii = gdspy.GdsLibrary()
  gdsii.read_gds(fn)
  ind = gdsii.extract('Al_Inductor_Islands_right')
  polys = ind.get_polygons()
  (xmin, ymin), (xmax, ymax) = ind.get_bounding_box()
  #ind_view = gdspy.CellReference(ind, [-xmin, -ymin])
  inductor = gdspy.Cell('Al_inductor')
  for poly in polys:
    polygon = gdspy.Polygon(poly, layer=3)
    polygon = polygon.translate(-xmin, -ymin)
    polygon = polygon.translate(-(xmax - xmin)/2, -(ymax - ymin)/2)
    inductor.add(polygon)
  inductor.flatten()
  return inductor

def main():
  # Wafer organization all dimensions in microns
  nrows = 8
  ncols = 8
  N_res = nrows * ncols
  ind = get_inductor()
  inv_ind = invert_cell(ind)
  # Generate all the capacitors
  L = 10 #nH
  fstart = 300 # MHz
  df = 3 #MHz
  fs = fstart + df * np.arange(N_res)

  capfrac = 1/(fs/fs[0])**2
  Cs = (1/(L*u.nH)/(2*np.pi*fs*u.MHz)**2).to(u.F).value
  idcs = [IDC(capfrac[i]) for i in range(N_res)]
  caps = []
  Nfingers = []
  cfracs = []
  for idc, c, freq in zip(idcs, Cs, fs):
    idc.finger_length = finger_length
    idc.cellname = "Capacitor_{0:3d}MHz".format(freq)
    nfinger, cfrac = getnumfingers(idc, c)
    Nfingers.append(nfinger)
    cfracs.append(cfrac)

  Nfinger = int(round(np.max(Nfingers)/10)*10)
  common_Nfinger = np.min(Nfingers)
  common_capfrac = capfrac[-1]

  common_idc = IDC(1.0)
  common_idc.nfinger = common_Nfinger
  common_idc.cellname = "Capacitor_common"
  common_cap = common_idc.draw(less_one=True)
  obtained_Cs = []
  for idc in idcs:
    idc.nfinger = Nfinger - common_Nfinger
    idc.capfrac = (idc.capfrac - common_capfrac)/(1 - common_capfrac)
    caps.append(idc.draw())
    obtained_Cs.append(idc.capacitance())

  obtained_Cs = np.array(obtained_Cs)
  fig, ax = plt.subplots(figsize=(10,10))
  ax.plot(Cs*1e12, obtained_Cs*1e12, 'bs-')
  ax.set_xlabel('Target C [pF]')
  ax.set_ylabel('Actual C [pF]')
  ax.grid()
  ax.axis('tight')
  plt.savefig('target_vs_actual_capacitance.png')
  plt.show()

  #  idcs.append(idc)
  #  caps.append(idc.draw())
  #for ires in range(N_res):
  #  print (idcs[ires].capacitance())
  common_resonator = gdspy.Cell('common_resonator')
  ind_origin = [island_halfwidth/2  + indboxwidth/2, 0]
  ind_ref = gdspy.CellReference(ind, origin = ind_origin)
  common_resonator.add(ind_ref)
  cap_ref = gdspy.CellReference(common_cap, rotation = 90)
  (xmin, ymin), (xmax, ymax) = cap_ref.get_bounding_box()
  cap_dx = -island_halfwidth/2 - (xmax-xmin)/2
  cap_ref.translate(cap_dx, 0)
  common_resonator.add(cap_ref)

  ms_width = 2
  dy = (finger_length + 3 * ms_width)/2 - ms_width/2
  print (dy/2 + ms_width/2)
  connector = make_cap_to_ind_lines()
  print (connector.get_bounding_box())
  top_conn_ref = gdspy.CellReference(connector, [0, dy/2 - ms_width/2] )
  bot_conn_ref = gdspy.CellReference(connector, x_reflection=True)
  #bot_conn_ref = gdspy.CellReference(connector, [0, -dy/2 - ms_width/2], x_reflection=True)
  print (bot_conn_ref.get_bounding_box())

  resonator_connector = gdspy.Cell('Cap_to_Ind_lines')
  resonator_connector.add(top_conn_ref)
  resonator_connector.add(bot_conn_ref)
  resonator_connector_ref = gdspy.CellReference(resonator_connector)
  common_resonator.add(resonator_connector_ref)


  gdspy.write_gds('sscale_darkres.gds',unit=1e-6,precision=1e-9)


if __name__=='__main__':
  main()


